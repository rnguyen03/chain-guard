import axios from 'axios';
import { CVEData, Vulnerability, Application } from '../types';

const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
const KREBS_RSS_URL = 'https://krebsonsecurity.com/feed/';
const HACKER_NEWS_RSS_URL = 'https://feeds.feedburner.com/TheHackersNews';

// Mock data for demo purposes
export const mockVulnerabilities: Vulnerability[] = [
  {
    id: 'vuln-1',
    cveId: 'CVE-2024-1234',
    description: 'Critical authentication bypass vulnerability in Slack Desktop application allowing unauthorized access to workspace data.',
    severity: 'CRITICAL',
    cvssScore: 9.8,
    affectedApps: [],
    publishedDate: '2024-10-01T10:00:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-1234']
  },
  {
    id: 'vuln-2',
    cveId: 'CVE-2024-5678',
    description: 'Remote code execution vulnerability in Zoom Client versions prior to 5.16.0.',
    severity: 'HIGH',
    cvssScore: 8.1,
    affectedApps: [],
    publishedDate: '2024-09-28T14:30:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-5678']
  },
  {
    id: 'vuln-3',
    cveId: 'CVE-2024-9012',
    description: 'Cross-site scripting (XSS) vulnerability in GitHub Enterprise Server.',
    severity: 'MEDIUM',
    cvssScore: 6.1,
    affectedApps: [],
    publishedDate: '2024-09-25T09:15:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-9012']
  },
  {
    id: 'vuln-4',
    cveId: 'CVE-2024-3456',
    description: 'Information disclosure vulnerability in Google Workspace admin console.',
    severity: 'LOW',
    cvssScore: 3.7,
    affectedApps: [],
    publishedDate: '2024-09-20T11:45:00Z',
    status: 'active',
    references: ['https://nvd.nist.gov/vuln/detail/CVE-2024-3456']
  }
];

export const mockApplications: Application[] = [
  {
    id: 'app-1',
    name: 'Slack',
    vendor: 'Slack Technologies',
    version: '4.35.0',
    category: 'Communication',
    addedDate: new Date().toISOString()
  },
  {
    id: 'app-2',
    name: 'Zoom',
    vendor: 'Zoom Video Communications',
    version: '5.15.5',
    category: 'Video Conferencing',
    addedDate: new Date().toISOString()
  },
  {
    id: 'app-3',
    name: 'GitHub',
    vendor: 'GitHub',
    version: 'Enterprise Server 3.10',
    category: 'Development',
    addedDate: new Date().toISOString()
  },
  {
    id: 'app-4',
    name: 'Google Workspace',
    vendor: 'Google',
    category: 'Productivity',
    addedDate: new Date().toISOString()
  }
];

/**
 * Fetch CVEs from NVD API
 * Note: NVD API has rate limits (5 requests per 30 seconds without API key)
 */
export const fetchCVEsFromNVD = async (
  keyword?: string,
  resultsPerPage: number = 10
): Promise<CVEData[]> => {
  try {
    const params: Record<string, string | number> = {
      resultsPerPage,
    };

    if (keyword) {
      params.keywordSearch = keyword;
    }

    const response = await axios.get(NVD_API_BASE, { params });
    return response.data.vulnerabilities.map((v: { cve: CVEData }) => v.cve);
  } catch (error) {
    console.error('Error fetching CVEs from NVD:', error);
    throw error;
  }
};

/**
 * Match vulnerabilities with tracked applications
 */
export const matchVulnerabilitiesToApps = (
  vulnerabilities: Vulnerability[],
  applications: Application[]
): Vulnerability[] => {
  return vulnerabilities.map(vuln => {
    const affectedApps = applications
      .filter(app => {
        // Simple string matching - in production, this would be more sophisticated
        const vulnText = `${vuln.description} ${vuln.cveId}`.toLowerCase();
        const appName = app.name.toLowerCase();
        const vendorName = app.vendor.toLowerCase();
        
        return vulnText.includes(appName) || vulnText.includes(vendorName);
      })
      .map(app => app.id);

    return {
      ...vuln,
      affectedApps
    };
  });
};

/**
 * Get mock data for demo
 */
export const getMockData = (applications: Application[]) => {
  return {
    vulnerabilities: matchVulnerabilitiesToApps(mockVulnerabilities, applications),
    applications: applications.length > 0 ? applications : mockApplications
  };
};

/**
 * Convert CVE data from NVD to our Vulnerability format
 */
export const convertCVEtoVulnerability = (cve: CVEData): Vulnerability => {
  const description = cve.descriptions.find(d => d.lang === 'en')?.value || 'No description available';
  const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0;
  const severity = cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity || 'LOW';

  return {
    id: cve.id,
    cveId: cve.id,
    description,
    severity: severity.toUpperCase() as 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW',
    cvssScore,
    affectedApps: [],
    publishedDate: cve.published,
    lastModifiedDate: cve.lastModified,
    references: cve.references?.map(r => r.url) || [],
    status: 'active'
  };
};

/**
 * Fetch recent CVEs from NVD (last 7 days)
 */
export const fetchRecentCVEs = async (days: number = 7): Promise<CVEData[]> => {
  try {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    const startDateStr = startDate.toISOString().split('T')[0];
    
    const params = {
      pubStartDate: startDateStr,
      resultsPerPage: 100,
      sortBy: 'publishedDate',
      sortOrder: 'desc'
    };

    const response = await axios.get(NVD_API_BASE, { params });
    return response.data.vulnerabilities.map((v: { cve: CVEData }) => v.cve);
  } catch (error) {
    console.error('Error fetching recent CVEs:', error);
    throw error;
  }
};

/**
 * Monitor for new vulnerabilities affecting tracked applications
 */
export const monitorNewVulnerabilities = async (
  applications: Application[],
  lastCheckTime?: Date
): Promise<Vulnerability[]> => {
  try {
    // Fetch recent CVEs
    const recentCVEs = await fetchRecentCVEs(1); // Last 24 hours
    
    // Filter CVEs published after last check
    const newCVEs = lastCheckTime 
      ? recentCVEs.filter(cve => new Date(cve.published) > lastCheckTime)
      : recentCVEs;

    // Convert to vulnerabilities and match with applications
    const vulnerabilities = newCVEs.map(convertCVEtoVulnerability);
    const matchedVulnerabilities = matchVulnerabilitiesToApps(vulnerabilities, applications);

    // Return only vulnerabilities that affect tracked applications
    return matchedVulnerabilities.filter(vuln => vuln.affectedApps.length > 0);
  } catch (error) {
    console.error('Error monitoring new vulnerabilities:', error);
    return [];
  }
};

/**
 * Parse RSS feed for security news (simplified version)
 * Note: In production, you'd want to use a proper RSS parser library
 */
export const parseSecurityNews = async (): Promise<Array<{title: string, link: string, published: string}>> => {
  try {
    // This is a simplified implementation
    // In production, you'd use a proper RSS parser like 'rss-parser'
    const newsItems = [
      {
        title: "New Supply Chain Attack Targets Popular SaaS Applications",
        link: "https://example.com/supply-chain-attack",
        published: new Date().toISOString()
      },
      {
        title: "Critical Vulnerability Found in Enterprise Communication Tools",
        link: "https://example.com/communication-vuln",
        published: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString() // 2 hours ago
      }
    ];
    
    return newsItems;
  } catch (error) {
    console.error('Error parsing security news:', error);
    return [];
  }
};

/**
 * Enhanced matching algorithm with fuzzy matching and keyword extraction
 */
export const enhancedMatchVulnerabilitiesToApps = (
  vulnerabilities: Vulnerability[],
  applications: Application[]
): Vulnerability[] => {
  return vulnerabilities.map(vuln => {
    const affectedApps = applications.filter(app => {
      // Extract keywords from vulnerability description
      const vulnKeywords = extractKeywords(vuln.description);
      const appKeywords = extractKeywords(`${app.name} ${app.vendor}`);
      
      // Check for exact matches
      const exactMatch = vuln.description.toLowerCase().includes(app.name.toLowerCase()) ||
                        vuln.description.toLowerCase().includes(app.vendor.toLowerCase());
      
      // Check for keyword overlap
      const keywordMatch = vulnKeywords.some(keyword => 
        appKeywords.some(appKeyword => 
          keyword.includes(appKeyword) || appKeyword.includes(keyword)
        )
      );
      
      return exactMatch || keywordMatch;
    }).map(app => app.id);

    return {
      ...vuln,
      affectedApps
    };
  });
};

/**
 * Extract keywords from text for better matching
 */
const extractKeywords = (text: string): string[] => {
  const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
  
  return text.toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 2 && !commonWords.includes(word))
    .slice(0, 10); // Limit to top 10 keywords
};
